package tui

import (
	"context"
	"testing"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/hector/easy-commit/internal/application"
	"github.com/hector/easy-commit/internal/config"
	"github.com/hector/easy-commit/internal/domain"
	"github.com/hector/easy-commit/internal/infrastructure/git"
	"github.com/hector/easy-commit/internal/infrastructure/tui/components"
	"github.com/hector/easy-commit/internal/shared"
)

// TestNewModel tests model initialization
func TestNewModel(t *testing.T) {
	cfg := config.DefaultConfig()
	logger := shared.NewLogger(shared.ERROR)
	gitRepo := git.NewExecutor(logger, &cfg.Timeouts)
	validator := application.NewConcurrentValidator(&cfg.Validator)
	service := application.NewCommitService(gitRepo, validator, logger, cfg)
	commitTypes := domain.CommitTypes{}.GetDefault()
	ctx := context.Background()

	model := NewModel(service, commitTypes, ctx)

	if model.currentStep != StepTypeSelect {
		t.Errorf("Expected initial step to be StepTypeSelect, got %v", model.currentStep)
	}

	if model.commit == nil {
		t.Error("Expected commit to be initialized")
	}

	if model.cancelled {
		t.Error("Expected cancelled to be false initially")
	}
}

// TestModelStepProgression tests stepping through the flow
func TestModelStepProgression(t *testing.T) {
	logger := shared.NewLogger(shared.ERROR)
	gitRepo := git.NewExecutor(logger)
	validator := application.NewConcurrentValidator(4)
	service := application.NewCommitService(gitRepo, validator, logger)
	commitTypes := domain.CommitTypes{}.GetDefault()
	ctx := context.Background()

	model := NewModel(service, commitTypes, ctx)

	// Step 1: Select type
	if model.currentStep != StepTypeSelect {
		t.Errorf("Expected StepTypeSelect, got %v", model.currentStep)
	}

	// Simulate type selection
	model.commit.Type = commitTypes[0]
	model.currentStep = StepDescription

	// Step 2: Description
	if model.currentStep != StepDescription {
		t.Errorf("Expected StepDescription, got %v", model.currentStep)
	}

	// Set valid description
	model.commit.Description = "add user authentication"
	model.currentStep = StepScope

	// Step 3: Scope
	if model.currentStep != StepScope {
		t.Errorf("Expected StepScope, got %v", model.currentStep)
	}
}

// TestModelCancellation tests cancellation
func TestModelCancellation(t *testing.T) {
	logger := shared.NewLogger(shared.ERROR)
	gitRepo := git.NewExecutor(logger)
	validator := application.NewConcurrentValidator(4)
	service := application.NewCommitService(gitRepo, validator, logger)
	commitTypes := domain.CommitTypes{}.GetDefault()
	ctx := context.Background()

	model := NewModel(service, commitTypes, ctx)

	// Simulate Ctrl+C
	msg := tea.KeyMsg{Type: tea.KeyCtrlC}
	updatedModel, cmd := model.Update(msg)

	result := updatedModel.(Model)
	if !result.cancelled {
		t.Error("Expected model to be cancelled")
	}

	if !result.quitting {
		t.Error("Expected model to be quitting")
	}

	if cmd == nil {
		t.Error("Expected quit command")
	}
}

// TestModelBackNavigation tests going back with Ctrl+B
func TestModelBackNavigation(t *testing.T) {
	logger := shared.NewLogger(shared.ERROR)
	gitRepo := git.NewExecutor(logger)
	validator := application.NewConcurrentValidator(4)
	service := application.NewCommitService(gitRepo, validator, logger)
	commitTypes := domain.CommitTypes{}.GetDefault()
	ctx := context.Background()

	model := NewModel(service, commitTypes, ctx)

	// Move to description step
	model.currentStep = StepDescription

	// Go back with Ctrl+B
	msg := tea.KeyMsg{Type: tea.KeyCtrlB}
	updatedModel, _ := model.Update(msg)

	result := updatedModel.(Model)
	if result.currentStep != StepTypeSelect {
		t.Errorf("Expected to go back to StepTypeSelect, got %v", result.currentStep)
	}
}

// TestModelDescriptionValidation tests description validation
func TestModelDescriptionValidation(t *testing.T) {
	tests := []struct {
		name        string
		description string
		valid       bool
	}{
		{"valid description", "add user auth", true},
		{"empty description", "", false},
		{"too long description", "this is a very long description that exceeds the maximum allowed length for conventional commits which is seventy-two characters", false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := components.ValidateDescription(tt.description)
			if result.Valid != tt.valid {
				t.Errorf("Expected validation result %v for %q, got %v", tt.valid, tt.description, result.Valid)
			}
		})
	}
}

// TestCommitTypeSelection tests commit type selection
func TestCommitTypeSelection(t *testing.T) {
	commitTypes := domain.CommitTypes{}.GetDefault()

	if len(commitTypes) == 0 {
		t.Error("Expected commit types to be defined")
	}

	// Check for specific types
	foundFeat := false
	foundFix := false
	for _, ct := range commitTypes {
		if ct.Name == "feat" {
			foundFeat = true
		}
		if ct.Name == "fix" {
			foundFix = true
		}
	}

	if !foundFeat {
		t.Error("Expected to find 'feat' commit type")
	}

	if !foundFix {
		t.Error("Expected to find 'fix' commit type")
	}
}

// TestConfirmationToggle tests confirmation state toggle
func TestConfirmationToggle(t *testing.T) {
	confirmation := components.NewConfirmation("Test?")

	// Initially should be Yes
	if !confirmation.YesSelected {
		t.Error("Expected initial state to be Yes")
	}

	// Toggle to No
	confirmation.Toggle()
	if confirmation.YesSelected {
		t.Error("Expected state to be No after toggle")
	}

	// Toggle back to Yes
	confirmation.Toggle()
	if !confirmation.YesSelected {
		t.Error("Expected state to be Yes after second toggle")
	}
}

// TestModelCommitBuild tests building a commit through the model
func TestModelCommitBuild(t *testing.T) {
	logger := shared.NewLogger(shared.ERROR)
	gitRepo := git.NewExecutor(logger)
	validator := application.NewConcurrentValidator(4)
	service := application.NewCommitService(gitRepo, validator, logger)
	commitTypes := domain.CommitTypes{}.GetDefault()
	ctx := context.Background()

	model := NewModel(service, commitTypes, ctx)

	// Find feat type
	var featType domain.CommitType
	for _, ct := range commitTypes {
		if ct.Name == "feat" {
			featType = ct
			break
		}
	}

	// Build a commit
	model.commit.Type = featType
	model.commit.Description = "add new feature"
	model.commit.Scope = "api"
	model.commit.Body = "This adds a new feature to the API"
	model.commit.Breaking = false

	// Verify commit is built correctly
	if model.commit.Type.Name != "feat" {
		t.Errorf("Expected type 'feat', got %s", model.commit.Type.Name)
	}

	if model.commit.Description != "add new feature" {
		t.Errorf("Expected description 'add new feature', got %s", model.commit.Description)
	}

	if model.commit.Scope != "api" {
		t.Errorf("Expected scope 'api', got %s", model.commit.Scope)
	}

	// Test formatting
	formatted := model.commit.Format()
	if formatted == "" {
		t.Error("Expected formatted commit message to be non-empty")
	}
}

// TestWindowResize tests window size handling
func TestWindowResize(t *testing.T) {
	logger := shared.NewLogger(shared.ERROR)
	gitRepo := git.NewExecutor(logger)
	validator := application.NewConcurrentValidator(4)
	service := application.NewCommitService(gitRepo, validator, logger)
	commitTypes := domain.CommitTypes{}.GetDefault()
	ctx := context.Background()

	model := NewModel(service, commitTypes, ctx)

	// Simulate window resize
	msg := tea.WindowSizeMsg{Width: 100, Height: 30}
	updatedModel, _ := model.Update(msg)

	result := updatedModel.(Model)
	if result.width != 100 {
		t.Errorf("Expected width 100, got %d", result.width)
	}

	if result.height != 30 {
		t.Errorf("Expected height 30, got %d", result.height)
	}
}
